이중 연결 리스트(Doubly Linked List)
    기본적으로 연결리스트와 비슷함
    포인터가 하나 추가됨(prev)
    특정 연산에서 연결리스트보다 성능이 뛰어남(pop)
    다만, 메모리를 더 많이 차지함(more memory===more flexibility)
    연결리스트는 한 방향으로, 이중 연결리스트는 양 방향으로 이어짐

    push 의사코드
    1.값을 받고 새로운 노드를 생성한다
    2.만약 리스트가 비어있으면 헤드와 테일을 새로운 노드에 설정한다
        3.else, 테일의 next를 새로운 노드로 지정한다
        4.새로운 노드의 prev를 테일로 지정한다
        5.새로운 노드를 테일로 지정한다
    6.길이를 1 증가한다.
    7.리스트를 반환한다.

    pop 의사코드
    1.만약 헤드(테일이나 길이가 0)가 없으면, Undefined 반환
    2.나중에 반환하기 위해 지금의 테일을 변수에 저장
    3.만약 길이가 1이면 헤드와 테일을 널로 해줘야함(리스트가 비기 때문에)
    4.테일의 prev를 테일로 지정
    5.원래 테일의 prev를 널로 지정
    6.테일의 next를 널로 지정
    7.길이 1 감소
    8.원래 테일 반환

    shift 의사코드
    1.만약, 헤드가 없다면 undefined 반환
    2.만약 길이가 1이라면 헤드와 테일을 널로 지정
    3.원래 헤드의 값을 변수에 저장
    4.헤드의 next를 헤드로 지정
    4.원래 헤드의 next를 널로 지정
    5.헤드의 prev를 널로 지정
    6.길이 1 감소
    7.원래 헤드 노드 반환

    unshift 의사코드
    1.값을 받고 새로운 노드 생성
    2.만약 헤드가 없다면 새로운 노드를 헤드와 테일로 설정
    3.else
        새로운 노드의 Next를 헤드로 지정
        헤드의 prev를 새로운 노드로 지정
        새로운 노드를 헤드로 지정
    4.길이 1 증가
    5.리스트 반환

    get 의사코드
    1.만약 찾는 인덱스가 음수이거나 리스트의 길이와 같다면 null 반환
    2. 찾는 인덱스가 리스트 길이의 반보다 큰지 작은지 구분
        반보다 크면 테일에서부터 중간까지 방향으로 루프 돌리고 노드 반환
        작으면 헤드에서부ㅌ 중간까지 방향으로 루프 돌리고 노드 반환
    
    set 의사코드
    1.바꿀 값과 인덱스를 받기
    2.get으로 노드 얻기
        유효한 노드를 받았으면 해당 노드의 값을 입력받은 값으로 바꿔준후 true 반환
        그렇지않으면(유효하지 않으면) false 반환

    insert 의사코드
    1.만약 찾는 인덱스가 0보다 작거나 리스트의 길이 초과이면 false 반환
    2.만약 찾는 인덱스가 0이면 unshift 반환
    3.만약 찾는 인덱스가 리스트의 길이이면 push 반환
    4. get 메소드로 index-1에 접근(삽일할 위치 전의 노드)
    5.index-1과 삽입할 노드와 index의 위치에 있는 노드의 next와 prev를 올바르게 설정
    6.길이 1 증가
    7.true 반환

    remove 의사코드
    1.만약 찾는 인덱스가 0보다 작거나 리스트의 길이 이상이면 undefined 반환
    2.만약 찾는 인덱스가 0이면 shift
    3.만약 찾는 인덱스가 length-1이면 pop
    4.get 메소드로 제거할 노드 찾기
    5.index-1과 index+1 위치의 노드의 next와 prev 속성 제대로 해주기
    6.삭제할 노드의 next와 prev를 null로 설정
    7.길이 1 감소
    8.삭제할 노드 반환

    BigO

    Insertion - o(1)
    Removal - O(1)
    Searching - O(n) (정확히 말하면 1/2n)
    Access - O(n)
