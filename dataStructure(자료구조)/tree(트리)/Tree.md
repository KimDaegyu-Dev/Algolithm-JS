트리(Tree)
    트리란
        parent-child 관계로 이루어진 노드를 가진 데이터 구조
        root - 트리의 가장 top node
        child - 다른 노드와 직접적으로 연결됐지만 root노드와 멀어지는 방향으로 연결된 노드
        parent - child의 반대
        sibling - 같은 parent를 가진 노드들의 그룹
        leaf - child가 없는 노드

    트리와 리스트, 배열의 차이
        리스트 배열은 linear 자료구조(노드 다음 노드 다음 노드)
        트리는 Non-linear 자료구조(가지가 여러갈래로 뻗을 수 있음)

    트리의 실생활 활용 예
        HTML DOM
        네트워크 라우팅
        Abstract Syntax Tree - 프로그래밍 언어의 구문을 보여주는 방법
        AI
        운영체제의 폴더 시스템
        JSON

    트리, 이진트리, 이진탐색트리(BST)의 차이
        트리는 자식의 개수 제한이 없음
        이진트리는 자식이 0,1,2 개 중 하나여야함
        이진검새트리는 데이터가 순서에 따라 저장되어 정렬되어 있음,
        자기보다 작은건 왼쪽 자식, 큰건 오른쪽 자식
    
    insert 의사코드
    0.값이 루트 노드와 같은 엣지케이스를 처리할 방법을 생각해야함
    1.값을 받아서 새 노드를 만든다
    2.루트가 없으면 새로운 노드를 루트로 지정
    3.루트에서부터 시작해서 값이 현재 노드보다 큰지 작은지 비교한다
        크면 오른쪽 자식 노드가 있는지 확인한다
            있으면 그 노드로 이동 후 다시 비교한다
            없으면 노드를 그 자리에 위치한다
        작으면 왼쪽 자식 노드가 있는지 확인한다
            있으면 그 노드로 이동 후 다시 비교한다
            없으면 노드를 그 자리에 위치한다
    5.전체 트리 반환

    find 의사코드
    1.루트에서 시작
        루트가 없으면 undefined반환
        노드가 있다면 노드와 찾는 값이 일치하는지 비교
        찾는 값이 아니면 큰지 작은지 비교
            크면 오른쪽에 노드가 있는지 확인
            있으면 노드로 이동, 없으면 못 찾은 것
            작으면 왼쪽에 노드가 있는지 확인
            있으면 노드로 이동, 없으면 못 찾은 것
    BigO
        Insertion - O(logn)
        Searching - O(logn)
        다만 보장되지는 않음

    트리 순회
        트리 순회는 일반적인 트리 모두에 적용할 수 있음

        Breadth First Search
        -Iteratively
            큐를 만들고 방문한 노드를 저장할 변수 생성
            루트 노드를 큐에 넣기
            큐에 노드가 남아 있는동안 루프
                큐에서 노드를 dequeue하고 노드를 저장하는 변수에 push
                만약 dequeue된 노드의 왼쪽 자식이 있다면 큐에 추가
                만약 dequeue된 노드의 오른쪽 자식이 있다면 큐에 추가
            방문한 노드를 저장한 변수 반환

        Depth First Search
        트리의 맨 밑에 도달할 때까지 형제 노드 방문은 하지 않고 내려감

        3가지 순서
        PreOrder(전위순회)
            노드 방문 - 왼쪽 노드 방문 - 오른쪽 노드 방문
            의사코드
            1.방문한 노드의 값을 저장할 변수 생성
            2.current 변수에 트리의 루트 노드 저장
            3.노드를 매개변수로 받는 헬터 함수 작성
                값을 저장하는 변수에 노드의 값 푸쉬
                만약 왼쪽 자식이 존재하면 왼쪽 자식 노드를 인자로 헬퍼 함수 호출
                만약 오른쪽 자식이 존재하면 오른쪽 자식 노드를 인자로 헬퍼 함수 호출
            4.현재 current변수를 매개로 헬퍼 함수 호출
            5.값을 저장한 변수 반환

        InOrder(중위순회)
            왼쪽 노드 방문 - 노드 방문 - 오른쪽 노드 방문
            의사코드
            위의 코드와 동일하나 순서만 바뀜
                만약 왼쪽 자식이 존재하면 왼쪽 자식 노드를 인자로 헬퍼 함수 호출
                값을 저장하는 변수에 노드의 값 푸쉬
                만약 오른쪽 자식이 존재하면 오른쪽 자식 노드를 인자로 헬퍼 함수 호출

        PostOrder(후위순회)
            왼쪽 노드 방 문- 오른쪽 노드 방문 - 노드 방문
            의사코드
                만약 왼쪽 자식이 존재하면 왼쪽 자식 노드를 인자로 헬퍼 함수 호출
                만약 오른쪽 자식이 존재하면 오른쪽 자식 노드를 인자로 헬퍼 함수 호출
                값을 저장하는 변수에 노드의 값 푸쉬
    
        DFS와 BFS는 언제 사용되는가?
        둘의 시간 복잡도는 같고, 공간 복잡도에 차이가 있음

        DFS는 노드의 개수가 꽉채워져있고 넓다면 큐에 노드가 많이 차서 메모리를 많이 먹음
        그러나 깊고 긴 트리는 큐에 저장되자마자 없어져서 메모리가 적게 사용됨

        BFS는 노드의 개수가 꽉채워져있고 넓다면 콜스택의 크기가 DFS와 비교했을 때 보다 적음
        그러나 깊고 긴 트리는 콜스택의 개수가 엄청 많아져서 메모리가 많이 사용됨
        
        중위순회는 순회 시 오름차순으로 결과가 나옴

        전위순회는 트리 구조를 "export" 할 때 쉽게 복구 가능하고 쉽게 복사 가능함
        트리를 복사하거나 평탄화해서 파일이나 데이테이스 같은 곳에 저장ㅇ하기 좋음
        자식이 무엇인지 알 수 있음

        후위순회는 순회 시 루트를 모르게됨, 잘 사용안함
        
